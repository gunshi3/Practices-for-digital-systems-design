C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE BEEP
OBJECT MODULE PLACED IN beep.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE beep.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**********************
   2          文件名称：beep.c
   3          作者：徐梓桑
   4          说明：进行音乐播放的例程,按下key1键后开始播放音乐
   5          修改记录：
   6          ***********************/
   7          
   8          /**********************
   9          基于STC15F2K60S2系列单片机C语言编程实现
  10          使用如下头文件，不用另外再包含"REG51.H"
  11          ***********************/
  12          #include <STC15F2K60S2.h>       //包含头文件
  13          #define uint unsigned int       //宏定义
  14          #define uchar unsigned char
  15          sbit Key1=P3^2;    //Key1对应触发外部中断0
  16          sbit beep=P3^4;                   //蜂鸣器
  17          sbit vibrate=P2^4;                //振动传感器
  18          uchar timeh,timel;                //定义定时器中断的重装值
  19          uchar jindu=0;                    //播放每首音乐时的进度值
  20          uchar gequ=0;                     //播放第几首音乐，默认为“0”--同一首歌
  21          uchar zanting=0;                  //暂停标志位
  22          bit flag;                                 //播放标志位
  23          uchar code music1[] ={    //音乐代码，歌曲为《同一首歌》，格式为: 音符, 节拍, 音符, 节拍,    
  24          0x15,0x20,0x21,0x10,     //音符的十位代表是低八度，中八度还是高八度，1代表高八度，2代表中八度，3代表高八度
  25          0x22,0x10,0x23,0x15,     //个位代表简谱的音符，例如0x15代表低八度的S0，0x21代表中八度的DO。
  26          0x24,0x05,0x23,0x10,     //节拍则是代表音长，例如：0x10代表一拍，0x20代表两拍，0x05代表1/2拍
  27          0x21,0x10,0x22,0x20,
  28          0x21,0x10,0x16,0x10,
  29          0x21,0x40,0x15,0x20,
  30          0x21,0x10,0x22,0x10,
  31          0x23,0x10,0x23,0x05,
  32          0x24,0x05,0x25,0x10,
  33          0x21,0x10,0x24,0x15,
  34          0x23,0x05,0x25,0x10,
  35          0x22,0x05,0x23,0x05,
  36          0x23,0x05,0x22,0x05,
  37          0x22,0x30,0x23,0x20,
  38          0x25,0x10,0x31,0x10,
  39          0x27,0x15,0x26,0x05,
  40          0x26,0x20,0x25,0x10,
  41          0x25,0x05,0x26,0x05,
  42          0x27,0x10,0x26,0x05,
  43          0x25,0x05,0x23,0x40,
  44          0x24,0x15,0x24,0x05,
  45          0x25,0x10,0x26,0x10,
  46          0x25,0x10,0x24,0x05,
  47          0x23,0x05,0x22,0x20,
  48          0x17,0x10,0x17,0x05,
  49          0x16,0x05,0x15,0x10,
  50          0x16,0x10,0x21,0x40,
  51          0x00,0x00
  52          };
  53          uchar code music2[] ={                     //《小毛驴》的音乐代码
  54          0x21,0x05,0x21,0x05,
  55          0x21,0x05,0x23,0x05,
C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 2   

  56          0x25,0x05,0x25,0x05,
  57          0x25,0x05,0x25,0x05,
  58          0x26,0x05,0x26,0x05,
  59          0x26,0x05,0x31,0x05,
  60          0x25,0x20,0x24,0x05,
  61          0x24,0x05,0x24,0x05,
  62          0x26,0x05,0x23,0x05,
  63          0x23,0x05,0x23,0x05,
  64          0x23,0x05,0x22,0x05,
  65          0x22,0x05,0x22,0x05,
  66          0x22,0x05,0x25,0x15,
  67          0x25,0x05,0x21,0x05,
  68          0x21,0x05,0x21,0x05,
  69          0x23,0x05,0x25,0x05,
  70          0x25,0x05,0x25,0x05,
  71          0x25,0x05,0x26,0x05,
  72          0x26,0x05,0x26,0x05,
  73          0x31,0x05,0x25,0x20,
  74          0x24,0x05,0x24,0x05,
  75          0x24,0x05,0x26,0x05,
  76          0x21,0x05,0x21,0x05,
  77          0x21,0x05,0x23,0x05,
  78          0x25,0x05,0x25,0x05,
  79          0x25,0x05,0x25,0x05,
  80          0x26,0x05,0x26,0x05,
  81          0x26,0x05,0x31,0x05,
  82          0x25,0x20,0x24,0x05,
  83          0x24,0x05,0x24,0x05,
  84          0x23,0x03,0x23,0x03,
  85          0x23,0x03,0x23,0x03,
  86          0x23,0x05,0x23,0x05,
  87          0x22,0x05,0x22,0x05,
  88          0x22,0x05,0x23,0x05,
  89          0x21,0x20,0x00,0x00
  90          };
  91          uchar code music3[] ={                     //《天空之城》的音乐代码
  92          
  93          0x16,0x05,0x17,0x05,
  94          0x21,0x15,0x17,0x05,
  95          0x21,0x10,0x23,0x10,
  96          0x17,0x30,0x23,0x10,
  97          0x16,0x15,0x15,0x05,
  98          0x16,0x10,0x21,0x10,
  99          0x15,0x30,0x13,0x10,
 100          0x14,0x15,0x13,0x05,
 101          0x14,0x05,0x21,0x05,
 102          0x21,0x10,0x13,0x30,
 103          0x21,0x10,0x17,0x10,
 104          0x14,0x05,0x14,0x10,
 105          0x17,0x10,0x17,0x20,
 106          0xff,
 107          0x16,0x05,0x17,0x05,
 108          0x21,0x15,0x17,0x05,
 109          0x21,0x10,0x23,0x10,
 110          0x17,0x30,0x13,0x05,
 111          0x13,0x05,0x16,0x15,
 112          0x15,0x05,0x16,0x10,
 113          0x21,0x10,0x15,0x30,
 114          0x13,0x10,0x14,0x10,
 115          0x21,0x05,0x17,0x05,
 116          0x17,0x10,0x21,0x10,
 117          0x22,0x10,0x23,0x05,
C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 3   

 118          0x21,0x20,0xff,
 119          0x21,0x05,0x17,0x05,
 120          0x16,0x10,0x17,0x10,
 121          0x15,0x10,0x16,0x20,
 122          0xff,
 123          0x21,0x05,0x22,0x05,
 124          0x23,0x15,0x22,0x10,
 125          0x23,0x10,0x24,0x10,
 126          0x25,0x05,0x22,0x30,
 127          0x15,0x10,0x22,0x03,
 128          0x21,0x03,0x17,0x03,
 129          0x21,0x03,0x21,0x10,
 130          0x21,0x05,0x22,0x10,
 131          0x23,0x05,0x23,0x40,
 132          0x16,0x05,0x17,0x05,
 133          0x21,0x10,0x17,0x05,
 134          0x21,0x05,0x22,0x10,
 135          0x21,0x15,0x15,0x05,
 136          0x15,0x20,0x24,0x10,
 137          0x23,0x10,0x22,0x10,
 138          0x21,0x10,0x23,0x30,
 139          0x16,0x05,0x17,0x05,
 140          0x21,0x15,0x17,0x05,
 141          0x21,0x10,0x23,0x10,
 142          0x17,0x30,0x13,0x10,
 143          0x16,0x15,0x15,0x05,
 144          0x16,0x10,0x21,0x10,
 145          0x15,0x30,0x13,0x10,
 146          0x14,0x10,0x21,0x05,
 147          0x17,0x05,0x17,0x10,
 148          0x21,0x10,0x22,0x10,
 149          0x23,0x05,0x21,0x05,
 150          0x21,0x20,0x21,0x05,
 151          0x17,0x05,0x16,0x10,
 152          0x17,0x10,0x15,0x10,
 153          0x16,0x40,0x00,0x00
 154          };
 155          uchar code quzi[] ={      //此数组数据为各个音符在定时器中的重装值，第一列是高位，第二列是低位
 156          0xf8,0x8c,        //低八度，低1
 157          0xf9,0x5b,        
 158          0xfa,0x15,        //低3
 159          0xfa,0x67,
 160          0xfb,0x04,        //低5
 161          0xfb,0x90,
 162          0xfc,0x0c,        //低7 
 163          0xfc,0x44,        //中央C调
 164          0xfc,0xac,        //中2
 165          0xfd,0x09,
 166          0xfd,0x34,        //中4
 167          0xfd,0x82,
 168          0xfd,0xc8,        //中6
 169          0xfe,0x06,
 170          0xfe,0x22,        //高八度，高1 
 171          0xfe,0x56,
 172          0xfe,0x6e,        //高3
 173          0xfe,0x9a,
 174          0xfe,0xc1,        //高5
 175          0xfe,0xe4,
 176          0xff,0x03         //高7
 177          };
 178          /**********************
 179          函数名称：void delay(unsigned int xms)
C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 4   

 180          功能描述：延时
 181          入口参数：xms：输入需要延时的毫秒值
 182          出口参数：无
 183          备注：
 184          
 185          ***********************/
 186          void delay(unsigned int xms)
 187          {
 188   1              uint i,j;                                                  
 189   1               for(i=xms;i>0;i--)
 190   1                      for(j=124;j>0;j--);
 191   1      }
 192          /**********************
 193          函数名称：uchar quyin(uchar tem)
 194          功能描述：在quzi数组中，找到music数组定义的简谱音符的重装值，并返回其在quzi数组中的位置
 195          入口参数：tem：music数组中定义的简谱音符
 196          出口参数：返回的是tem音符在quzi数组中的位置值
 197          备注：
 198          
 199          ***********************/
 200          uchar quyin(uchar tem)
 201          {
 202   1              uchar qudiao,jp,weizhi;           //定义曲调，音符和位置
 203   1              qudiao=tem/16;                            //高4位是曲调值
 204   1              jp=tem%16;                                        //低4位是音符
 205   1              if(qudiao==1)                             //当曲调值为1时，即是低八度，低八度在quzi数组中基址为0
 206   1                      qudiao=0;
 207   1              else if(qudiao==2)                        //当曲调值为2时，即是中八度，中八度在quzi数组中基址为14
 208   1                      qudiao=14;
 209   1              else if(qudiao==3)                        //当曲调值为3时，即是高八度，高八度在quzi数组中，基址为28
 210   1                      qudiao=28;
 211   1              weizhi=qudiao+(jp-1)*2;           //通过基址加上音符作为偏移量，即可定位此音符在quzi数组中的位置
 212   1              return weizhi;                            //返回这一个位置值
 213   1      }
 214          /**********************
 215          函数名称：void playmusic()
 216          功能描述：播放音乐
 217          入口参数：无
 218          出口参数：无
 219          备注：
 220          
 221          ***********************/
 222          void playmusic()
 223          {
 224   1              uchar p,m,tem;   //m为节拍      
 225   1              while(1)   
 226   1              {         while(zanting)                           //暂停选择位
 227   2                        beep=0;
 228   2                              if(gequ==0)                               //歌曲选择位为0，则播放同一首歌
 229   2                              {       
 230   3                                      p=music1[jindu];         
 231   3                                      if(p==0x00)                 //如果碰到结束符,延时1秒,回到开始再来一遍 
 232   3                                      {
 233   4                                              jindu=0;
 234   4                                              delay(1000);
 235   4                                              break;
 236   4                                      }        
 237   3                                      else if(p==0xff)   //若碰到休止符,延时100ms,继续取下一音符
 238   3                                      {
 239   4                                              jindu=jindu+1;
 240   4                                              delay(100);
 241   4                                              TR0=0;
C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 5   

 242   4                                              break;
 243   4                                      }      
 244   3                                      else                       //正常情况下取音符和节拍 
 245   3                                      {
 246   4                                              tem=quyin(music1[jindu]);               //取出当前音符在quzi数组中的位置值
 247   4                                              timeh=quzi[tem];                        //把音符相应的计时器重装载值赋予timeh和timel
 248   4                                              timel=quzi[tem+1];
 249   4                                              jindu++;
 250   4                                              TH0=timeh;                                      //把timeh和timel赋予计时器
 251   4                                              TL0=timel;
 252   4                                              m=music1[jindu];                                         //取得节拍
 253   4                                              jindu++;
 254   4                                      }                  
 255   3                              TR0=1;                    //开定时器1    
 256   3                                      delay(m*180);             //等待节拍完成, 通过P3^4口输出音频                        
 257   3                                      TR0=0;                    //关定时器1
 258   3                                      beep=0;                               //将beep置0，以保护蜂鸣器
 259   3                              }                                                                               
 260   2                              else if(gequ==1)                   //歌曲选择位为1，则播放小毛驴
 261   2                              {       
 262   3                                      p=music2[jindu];        
 263   3                                      if(p==0x00)                      //如果碰到结束符,延时1秒,回到开始再来一遍 
 264   3                                      {
 265   4                                              jindu=0;
 266   4                                              delay(1000);
 267   4                                              break;
 268   4                                      }        
 269   3                                      else if(p==0xff)   //若碰到休止符,延时100ms,继续取下一音符
 270   3                                      {
 271   4                                              jindu=jindu+1;
 272   4                                              delay(100);
 273   4                                              TR0=0;
 274   4                                              break;
 275   4                                      }      
 276   3                                      else                       //正常情况下取音符和节拍 
 277   3                                      {
 278   4                                              tem=quyin(music2[jindu]);               //取出当前音符在quzi数组中的位置值
 279   4                                              timeh=quzi[tem];                        //把音符相应的计时器重装载值赋予timeh和timel
 280   4                                              timel=quzi[tem+1];
 281   4                                              jindu++;
 282   4                                              TH0=timeh;                                      //把timeh和timel赋予计时器
 283   4                                              TL0=timel;
 284   4                                              m=music2[jindu];                                         //取得节拍
 285   4                                              jindu++;
 286   4                                      }                  
 287   3                              TR0=1;                    //开定时器1    
 288   3                                      delay(m*300);             //等待节拍完成, 通过P3^4口输出音频                            
 289   3                                      TR0=0;                    //关定时器1
 290   3                                      beep=0;                                          //将beep置0，以保护蜂鸣器
 291   3                              }
 292   2                              else if(gequ==2)                  //歌曲选择位为2，则播放天空之城
 293   2                              {       
 294   3                                      p=music3[jindu];         
 295   3                                      if(p==0x00)                      //如果碰到结束符,延时1秒,回到开始再来一遍 
 296   3                                      {
 297   4                                              jindu=0;
 298   4                                              delay(1000);
 299   4                                              break;
 300   4                                      }        
 301   3                                      else if(p==0xff)    //若碰到休止符,延时100ms,继续取下一音符
 302   3                                      {
 303   4                                              jindu=jindu+1;
C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 6   

 304   4                                              delay(100);
 305   4                                              TR0=0;
 306   4                                              break;
 307   4                                      }      
 308   3                                      else                       //正常情况下取音符和节拍 
 309   3                                      {
 310   4                                              tem=quyin(music3[jindu]);               //取出当前音符在quzi数组中的位置值
 311   4                                              timeh=quzi[tem];                        //把音符相应的计时器重装载值赋予timeh和timel
 312   4                                              timel=quzi[tem+1];
 313   4                                              jindu++;
 314   4                                              TH0=timeh;                                      //把timeh和timel赋予计时器
 315   4                                              TL0=timel;
 316   4                                              m=music3[jindu];                                         //取得节拍
 317   4                                              jindu++;
 318   4                                      }                  
 319   3                              TR0=1;                    //开定时器1    
 320   3                                  delay(m*200);             //等待节拍完成, 通过P3^4口输出音频                                
 321   3                                      TR0=0;                    //关定时器1
 322   3                                      beep=0;                                          //将beep置0，以保护蜂鸣器
 323   3                              }
 324   2                      }
 325   1      }
 326          /**********************
 327          函数名称：void init_sys()
 328          功能描述：系统初始化，功能是配置IO口
 329          入口参数：无
 330          出口参数：无
 331          备注：
 332          
 333          
 334          ***********************/
 335          void init_sys()
 336          {
 337   1              P0M0=0xff;                                               //设置推挽模式
 338   1              P0M1=0x00;
 339   1              P2M0=0x08;
 340   1              P2M1=0x00;
 341   1              P3M0=0x10;
 342   1              P3M1=0x00;
 343   1              P4M0=0x00;
 344   1              P4M1=0x00;
 345   1              P5M0=0x00;
 346   1              P5M1=0x00;
 347   1      }
 348          /**********************
 349          函数名称：void init()
 350          功能描述：定时器和外部中断的初始化
 351          入口参数：无
 352          出口参数：无
 353          备注：
 354          
 355          ***********************/
 356          void init()                                               
 357          {
 358   1              TMOD=0x01;                                        //设置定时器0，工作方式1，16位手动重装
 359   1              TH0=0xD8;                                         //定时器初值
 360   1              TL0=0xEF;
 361   1              IE=0x87;                                          // 1000 0111   EA=1,EX0=1,ET0=1,EX1=1
 362   1              IP=0x01;                                          // 0000 0001   PX0=1    外部中断0优先级高
 363   1              TR0=0;                                            //启动定时器0
 364   1              beep=0;
 365   1      }
C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 7   

 366          /**********************
 367          函数名称：Exint0
 368          功能描述：Key1对应的外部中断0的中断响应函数
 369          ***********************/
 370          void Exint0() interrupt 0         
 371          {
 372   1         if(Key1==0)
 373   1         { delay(10);                         //延时消抖
 374   2          if(Key1==0)
 375   2                      zanting=~zanting;    //zanting==1 暂停播放
 376   2         }       
 377   1      }
 378          void main()
 379          {
 380   1              init_sys();                      //系统初始化
 381   1              init();
 382   1              P0=0x00;
 383   1              vibrate=1;                      
 384   1              flag=0;                         //播放标志位清零
 385   1              while(1)
 386   1              {
 387   2                      playmusic();    //播放音乐函数
 388   2              }
 389   1      }
 390          /**********************
 391          函数名称：void time1() interrupt 1
 392          功能描述：定时器0中断处理，重新装值，并把beep值取反，产生方波
 393          入口参数：无
 394          出口参数：无
 395          备注：
 396          
 397          ***********************/
 398          void time1() interrupt 1                                                //计时器控制频率
 399          {
 400   1              TH0=timeh;                                                                 //手动重装初值
 401   1              TL0=timel;
 402   1      
 403   1          if(zanting==1)                                                         //判断是否暂停
 404   1                beep=0;
 405   1              else 
 406   1              {
 407   2                beep=~beep;
 408   2                if(vibrate==0)                                                   //判断是否振动
 409   2              {
 410   3                      jindu=0;                           //歌曲的进度清零，从头开始演唱
 411   3                      gequ++;                            //切换歌曲
 412   3                      if(gequ==3)                        //如果到达最后一首，从第一首开始
 413   3                      gequ=0;
 414   3              }  
 415   2              }
 416   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    471    ----
   CONSTANT SIZE    =    533    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.00   BEEP                                                                  08/15/2015 09:58:37 PAGE 8   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
