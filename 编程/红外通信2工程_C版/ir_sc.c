#include "STC15F2K60S2.H"

#define Check_Time 75					//按键消抖的周期
#define Min_time 50						//按键识别被为按下时需检测到的最少次数

/**********************
引脚别名定义
***********************/
sbit SEL0 = P2^0;								//位选信号
sbit SEL1 = P2^1;								//位选信号
sbit SEL2 = P2^2;								//位选信号
sbit SEL3 = P2^3;								//数码管和LED的选择信号

sbit P3_5 = P3^5;								//红外线发送引脚
sbit P3_7 = P3^7;								//串口1发送引脚

sbit KEY1 = P3^2;								//按键1  发送信号
sbit KEY2 = P3^3;								//按键2	 数据加1
sbit KEY3 = P1^7;								//按键3  收发模式开关


/**********************
全局变量定义
***********************/
int time = Check_Time;					//按键消抖周计数(一个周期检测Check_Time次)
int key1_count = 0;							//周期中检测到KEY1=0的次数
int key2_count = 0;							//周期中检测到KEY2=0的次数
int key3_count = 0;							//周期中检测到KEY3=0的次数
int key1_state = 1;							//KEY1状态：设置为0代表已按下，1代表未按下
int key2_state = 1;							//KEY2状态：设置为0代表已按下，1代表未按下
int key3_state = 1;							//KEY3状态：设置维0代表已按下，1代表未按下

unsigned int number[] = {0, 0, 0, 0, 0, 0, 0, 0};				//数码管显示的数字

int count = 1; 									//数码管显示的数量
int show_flag;									//扫描中显示的位
int s_count = 0;								//已发送数据的个数
int begin_recive = 0;						//接收开始标志
int mybuf = 11;										//数据接收缓冲

unsigned char seg_sel[]={				//段选，显示0-f
			0x3f,0x06,0x5b,0x4f,
			0x66,0x6d,0x7d,0x07,
			0x7f,0x6f,0x77,0x7c,
			0x39,0x5e,0x79,0x71};

/**********************
函数声明(中断函数除外)
***********************/
void TimerInit();			//定时器设置
void UartInit();			//串口1设置
void init();					//初始化，推挽，设置中断开关
void weixuan(int);		//设置数码管位选
void check_key();			//消抖检测以及按键操作(定时器0中断中调用)

/********************************
 * 函数名：main
 * 描述  ：主函数
 * 输入  ：无
 * 输出  ：无
********************************/
void main()
{
	TimerInit();		//设置定时器
	UartInit();			//设置串口1
	init();					//初始化
	while(1);
}

/********************************
 * 函数名：UartInit
 * 描述  ：串口1的相关设置
 * 输入  ：无
 * 输出  ：无
********************************/
void UartInit()		//设置方法见数据手册P621(串口1设置)和P498(定时器T1设置)
{	
	PCON &= 0x7F;		//波特率不倍速，SMOD=0
	SCON = 0x50;		//串口1使用工作方式1，REN=1(允许串行接收)
	AUXR &= 0xFE;		//串口1选择定时器T1作为波特率发生器，S1ST2=0
	AUXR1 = 0x40;		//串口1在P3.6接收，在P3.7发送
	PS = 1;					//设置串口中断为最高优先级
}

/********************************
 * 函数名：TimerInit
 * 描述  ：定时器的相关设置
 * 输入  ：无
 * 输出  ：无
********************************/
void TimerInit()	//设置方法见数据手册P498
{
	AUXR |= 0x40;		//定时器T1为1T模式，速度是传统8051的12倍，不分频。
	TMOD &= 0x0F;		//清除T1模式位
	TMOD |= 0x20;		//设置T1模式位，使用8位自动重装模式
	TL1 = 0x70;			//设置初值
	TH1 = 0x70;			//设置T1重装值
	TR1 = 1;				//T1运行控制位置1，允许T1计数
	
	AUXR |= 0x80;		//定时器T0为1T模式，的速度是传统8051的12倍，不分频。
	TMOD &= 0xF0;		//清除T0模式位
	TMOD |= 0x02;		//设置T0模式位，使用8位自动重装模式
	TL0 = 0x70;			//设置初值
	TH0 = 0x70;			//设T0重装值
	TF0 = 0;				//T0溢出标志位清零
	TR0 = 1;				//T0运行控制位置1，允许T0计数
	
	//定时器T2用于显示和按键消抖，500us定时16位自动重装
	AUXR |= 0x04;		//定时器T2为1T模式
	T2L = 0x66;			//低位重装值
	T2H = 0xEA;			//高位重装值
	AUXR |= 0x10;		//定时器2开始计时
}

/********************************
 * 函数名：init
 * 描述  ：设置推挽，中断开关设置
 * 输入  ：无
 * 输出  ：无
********************************/
void init()
{
	//设置推挽输出
	P0M1 = 0x00;
	P0M0 = 0xff;
	P2M1 = 0x00;
	P2M0 = 0x08;

	SEL3 = 0;
	//中断开关设置，详见数据手册P458
	ET1 = 0;			//禁止T1中断
	ET0 = 1;			//打开定时器T0中断
	ES = 1;				//打开串口1中断
	IE2 = 0X04;		//打开定时器2中断
	EA = 1;				//打开总中断
/*以上操作相当于：	
	IE = 0x92;		//打开总中断EA=1，打开串口1中断ES=1，打开定时器0中断ET0=1
*/
}

/********************************
 * 函数名：weixuan
 * 描述  ：数码管显示位的选择
 * 输入  ：需要显示的第x位
 * 输出  ：无
********************************/
void weixuan(int x)
{
	SEL0 = x%2;
	SEL1 = x%4/2;
	SEL2 = x/4;
}

/********************************
 * 函数名：check_key
 * 描述  ：消抖周期中一次按键的检测，以及检测Check_Time次后的操作（需要多次重复调用）
 * 输入  ：无
 * 输出  ：无
********************************/
void check_key()
{
	time--;
	if(KEY1==0)
		key1_count++;
	if(KEY2==0)
		key2_count++;
	if(KEY3==0)
		key3_count++;
	
	if(time <= 0)									//一个周期结束
	{
		if(key1_count>=Min_time)		//判断KEY1被检测为按下的次数是否大于按键识别被为按下需检测到的最少次数
		{
			if(key1_state==1)					//判断是否已经被按下
			{
					REN = 0;							//
					SBUF = 0xca;					//发出发送标志0xca，触发串口中断进行数据发送

					key1_state = 0;				//状态改变为已经被按下
			}
		}
		else
			key1_state = 1;						//状态改变为未被按下
		
		if(key2_count>=Min_time)
		{
			if(key2_state==1)
			{	
				number[8-count]++;								//数据+1
				number[8-count] %= 16;
				key2_state = 0;
			}
		}
		else
			key2_state = 1;
		
		if(key3_count>=Min_time)
		{
			if(key3_state==1)
			{
				count++;												//显示个数+1
				if(count == 9)
					count = 1;
				key3_state = 0;
			}
		}
		else
			key3_state = 1;
		
		time = Check_Time;
		key1_count = 0;
		key2_count = 0;
		key3_count = 0;
	}

}


/********************************
 * 函数名：Time0
 * 描述  ：定时器0中断的操作
 * 输入  ：无
 * 输出  ：无
********************************/
void Time0() interrupt 1
{
	if(P3_7==0)			//P3_5根据P3_7的信号产生脉冲
	{
		P3_5 = ~P3_5;
	}
	else						//如果P3.7=1则P3.5输出0
		P3_5 = 0;
}

/********************************
 * 函数名：URAT1
 * 描述  ：串口1中断的操作。发送完毕TI自动置1，产生中断; 接收完毕RI值1，产生中断
 * 输入  ：无
 * 输出  ：无
********************************/
void URAT1() interrupt 4
{
	if(TI)												//判断发送中断
	{
		TI = 0;											//发送中断请求标志位清0
		if(s_count < count)					//发送个数小于显示个数
		{
			SBUF = number[7-s_count];	//继续发送
			s_count ++;
		}
		else
		{
			if(s_count == count)			//发送个数等于显示个数
			{	
				s_count ++;
				SBUF = 0x55;						//发送结束标志
			}
			else											//发送完毕后，已发送个数清零，打开串口接收
			{
				s_count = 0;
				REN = 1;									
			}
		}
	}
	
	if(RI)												//判断是否接收中断
	{
		RI = 0;											//接收中断请求标志位清0
		mybuf = SBUF;								//把这次接收到的数据存入自定义的缓存中
		
		if(mybuf == 0x55)						//判断接收结束
		{
			begin_recive = 0;					//接收结束
			IE2 = 0x04;								//打开定时2中断
		}
		if(begin_recive)						//如果开始了
		{	
			number[7-count] = SBUF;		//接收数据
			count++;									//显示个数+1
		}
		if(mybuf == 0xca)						//判断开始接收标志
		{
			begin_recive = 1;					//接收开始
			IE2 = 0x00;								//关闭定时器T2中断，停止按键检测与数码管扫描
			P0 = 0;							
			count = 0;								//显示个数清零
		}
	}
}

/********************************
 * 函数名：Timer2
 * 描述  ：定时器2中断的操作。用于显示数码管和LED灯以及按键消抖
 * 输入  ：无
 * 输出  ：无
********************************/
void Timer2() interrupt 12
{
	
	P0 = 0;									//P0清零
	show_flag = (show_flag+1)%count;
	weixuan(7-show_flag);							//选择数码管的第七位
	P0 = seg_sel[number[7-show_flag]];		//设置数码管显示内容

	check_key();							//按键消抖检测
}
